这是Java学习中的一些代码以及重要的知识点

- 1 2018-10-16 熟悉idea中github使用
- 2 2018-10-17 添加.ignore插件，忽略不必要的文件
- 3 2018-10-17 添加覆盖隐藏、抽象类等学习注释
- 4 2018-10-22 添加类初始化
- 5 2018-10-26 学习Java疯狂讲义第一张，了解Java历史和基础只是
    - Java ME：只要用于控制移动设备和信息家电等有限存储设备。
    - Java SE：整个Java技术的核心和基础，它是ME和EE编程的基础。
    - Java EE：Java技术中应用最为广泛的部分，EE提供了企业应用开发相关的完整解决方案。
    - JDK：Java SE Development Kit，Java标准开发包，它提供了编译、运行Java程序所需要的各种工具和资源、包括Java编译器、Java运行时环境、以及常用的类库等。
    - JRE：Java运行时环境，它包含了JVM（Java虚拟机）还有类加载器、字节码校验器以及大量的基础类库。
- 6 2018-10-30 Java集合，HashSet和TreeSet（无序和有序）
- 7 2018-11-6 初识图形用户界面
    - JFC与Swing。JFC（Java Foundation Classes）
    - 关于GUI组建和服务的完整集合
    - 作为Java SE的一个有机部分，主要包含5个方面
    1. AWT
    2. Java2D
    3. Accessibility
    4. Drag & Drop
    5. Swing
    
    - **Swing**
    1. JFC的一部分
    2. 提供按钮、窗口、表格等所有组件
    3. 纯Java组件（完全用Java所写）
    
---

- Java反射

    1. Class类
        - 在面向对象的世界里，万事万物皆对象。java语言中，静态成员和普通数据类型不是对象。类是对象吗？
            - 类是对象，类是java.lang.Class类的实例对象（java中所有类都是Class的实例）
            - 这个对象如何表示？(ClassDemo1)
    
        - Class.forName("类的全称")
            - 不仅表示了类的类类型，还代表了动态加载类
            - 区分编译、运行
            - 编译时刻加载类是静态加载类、运行时刻加载类是动态加载类
    
        - 基本的数据类型
            - void关键字 基本数据类型都存在类类型
            
        - Class类的基本API操作
        
    2. 方法的反射
        - 如何获取某个方法：方法的名称和参数列表唯一确定某个方法
        - 方法反射的操作：method.invoke(对象,参数列表)
        
    3. 通过Class,Method来认识泛型的本质
    
---

- Effective Java

    1. 考虑用静态工厂方法代替构造器
        - 以静态工厂方法获取一个类的实例
        - 优点
            1. 静态工厂方法有名称
            2. 不必在每次调用它们的时候都创建一个新对象
            3. 可以返回原返回类型的任何子类型的对象
            4. 在创建参数化类型实例的时候，它们使代码变得更加简洁
        - 缺点
            1. 类如果不含公有的或者受保护的构造器，就不能被子类化
            2. 它们与其他静态方法实际上没有任何区别
    2. 遇到多个构造器参数时要考虑用构建器（非构造器）
        - 构造具有多个参数对象时使用构建起
        - 与使用传统的重叠构造器模式相比，使用builder模式的客户端代码更易于阅读和编写
        - 构建起比JavaBeans更加安全，因为它的构造过程被分到了几个调用中，在构造过程中JavaBean可能处于不一致的状态
    3. 用私有构造器强化Singleton属性
    4. 通过私有构造器强化不可实例化的能力
        - 工具类的静态方法类似于c++中某名称空间内的函数，该类实例化没有任何意义
    5. 避免创建不必要的对象
    6. 消除过期的对象引用
    7. 避免使用终结方法
    8. 覆盖equals时请遵守通用约定
        1. 自反性
        2. 对称性
        3. 传递性
        4. 一致性
        - 实现高质量equals的方法
            1. 使用==操作符检查"参数是否为这个对象的引用".(是一种性能优化,如果比较操作有可能很昂贵,就值得这么做)
            2. 使用instanceof操作符检查"参数是否为正确的类型"
            3. 吧参数转换成正确的类型
            4. 对于该类的每个"关键"域,检查参数中的域是否与该对象中对应的域想匹配
    9. 覆盖equals时总要覆盖hashCode(为了结合所有基于散列的集合一起正常运作)
        - 如果相等的对象具有不等的散列,那么在散列集合中获取对象会出现意外的意外的情况
        - hashCode编写规则->Effective Java P41
        - java 7 -> Objects.hash(Object...values) -> Arrays.hashCode(xxx[] values)
    10. 始终要覆盖toString方法